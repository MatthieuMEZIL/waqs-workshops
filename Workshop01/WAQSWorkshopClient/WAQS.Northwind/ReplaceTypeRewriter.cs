//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using WAQS.ClientContext.Interfaces.ExpressionSerialization;

namespace WAQS.ClientContext
{
    public class ReplaceTypeRewriter<OldT, NewT> : SerializableExpressionRewriter
    {
        protected internal override SerializableExpression VisitConditional(SerializableConditionalExpression expression)
        {
            Type newType = ReplaceType(expression.Type.Type);
            if (newType != expression.Type.Type)
                return new SerializableConditionalExpression(Visit(expression.TestExpression), Visit(expression.IfTrueExpression), Visit(expression.IfFalseExpression), new SerializableType(newType));
            return base.VisitConditional(expression);
        }
    
        protected internal override SerializableExpression VisitConstant(SerializableConstantExpression expression)
        {
            Type newType = ReplaceType(expression.Type.Type);
            if (newType != expression.Type.Type)
            {
                if (expression.Delegate != null)
                    return new SerializableConstantExpression(expression.Delegate, newType);
                return new SerializableConstantExpression(expression.Value, newType);
            }
            return base.VisitConstant(expression);
        }
    
        protected internal override SerializableExpression VisitConstructor(SerializableConstructorExpression expression)
        {
            bool argumentTypeChanged = false;
            var argumentTypes = new List<SerializableType>(expression.ArgumentTypes);
            Type newType;
            for (int argumentTypeIndex = 0; argumentTypeIndex < argumentTypes.Count; argumentTypeIndex++)
                if ((newType = ReplaceType(argumentTypes[argumentTypeIndex].Type)) != argumentTypes[argumentTypeIndex].Type)
                {
                    argumentTypes[argumentTypeIndex] = new SerializableType(newType);
                    argumentTypeChanged = true;
                }
            if ((newType = ReplaceType(expression.Type.Type)) != expression.Type.Type || argumentTypeChanged)
                return new SerializableConstructorExpression(new SerializableType(newType), argumentTypes, expression.Arguments.Select(a => Visit(a)).ToList());
            return base.VisitConstructor(expression);
        }
    
        protected internal override SerializableExpression VisitLambda(SerializableLambdaExpression expression)
        {
            Type newType = ReplaceType(expression.ReturnType.Type);
            if (newType != expression.ReturnType.Type)
                return new SerializableLambdaExpression(expression.Parameters.Select(p => (SerializableParameterExpression)Visit(p)).ToList(), new SerializableType(newType), Visit(expression.Body));
            return base.VisitLambda(expression);
        }
    
        protected internal override SerializableExpression VisitPropertyGetter(SerializablePropertyGetterExpression expression)
        {
            Type newType = ReplaceType(expression.MemberDeclaringType.Type);
            if (newType != expression.MemberDeclaringType.Type)
                return new SerializablePropertyGetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name));
            return base.VisitPropertyGetter(expression);
        }
    
        protected internal override SerializableExpression VisitPropertySetter(SerializablePropertySetterExpression expression)
        {
            Type newType = ReplaceType(expression.MemberDeclaringType.Type);
            if (newType != expression.MemberDeclaringType.Type)
                return new SerializablePropertySetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name), Visit(expression.Value));
            return base.VisitPropertySetter(expression);
        }
    
        protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
        {
            Type newType = ReplaceType(expression.MemberDeclaringType.Type);
            MethodInfo method;
            if (newType == expression.MemberDeclaringType.Type)
            {
                method = expression.Method;
                if (!method.IsGenericMethod)
                    return base.VisitMethodCall(expression);
                method = method.GetGenericMethodDefinition();
            }
            else
                method = newType.GetMethod(expression.Method.Name, expression.Method.GetParameters().Select(p => ReplaceType(p.ParameterType)).ToArray());
            if (method.IsGenericMethod)
                method = method.MakeGenericMethod(expression.GenericArguments.Select(ga => ReplaceType(ga.Type)).ToArray());
            return new SerializableMethodCallExpression(Visit(expression.Source), expression.Parameters.Select(p => Visit(p)), method);
        }
    
        protected internal override SerializableExpression VisitParameter(SerializableParameterExpression expression)
        {
            Type newType = ReplaceType(expression.Type.Type);
            if (newType != expression.Type.Type)
                return new SerializableParameterExpression { Name = expression.Name, Type = new SerializableType(newType) };
            return base.VisitParameter(expression);
        }
    
        protected internal override SerializableExpression VisitUnary(SerializableUnaryExpression expression)
        {
            Type newType = ReplaceType(expression.Type.Type);
            if (newType != expression.Type.Type)
                return new SerializableUnaryExpression(expression.Operand, expression.NodeType, new SerializableType(newType));
            return base.VisitUnary(expression);
        }
    
        protected internal override SerializableExpression VisitTypeBinary(SerializableTypeBinaryExpression expression)
        {
            Type newType = ReplaceType(expression.TypeOperand.Type);
            if (newType != expression.TypeOperand.Type)
                return new SerializableTypeBinaryExpression(expression.Expression, expression.NodeType, new SerializableType(newType));
            return base.VisitTypeBinary(expression);
        }
    
        private static Type ReplaceType(Type type)
        {
            if (type == typeof(OldT))
                return typeof(NewT);
            if (type.IsGenericType)
                return type.GetGenericTypeDefinition().MakeGenericType(type.GetGenericArguments().Select(t => ReplaceType(t)).ToArray());
            return type;
        }
    }
}

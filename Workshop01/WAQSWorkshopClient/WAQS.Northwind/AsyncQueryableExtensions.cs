//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Threading.Tasks;
using WAQS.ClientContext.Interfaces.ExpressionSerialization;
using WAQS.ClientContext.ExpressionSerialization;
using WAQS.EntitiesTracking;
using WAQS.ClientContext.Interfaces;

namespace WAQS.ClientContext
{
    public static class AsyncQueryableExtensions
    {
        public static Task<IEnumerable<T>> ExecuteAsync<T>(this IAsyncQueryable<T> query, MergeOption? mergeOption = null)
        {
            return query.Context.ExecuteQueryAsync(query, mergeOption);
        }
        public static Task<T> ExecuteAsync<T>(this IAsyncQueryableValue<T> query, MergeOption? mergeOption = null)
        {
            return query.Context.ExecuteQueryAsync(query, mergeOption);
        }
                
        public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return Any<TSource>(source, serializablePredicateReference.Value);
        }
                
        public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return Any<TSource>(source, serializablePredicateReference.Value);
        }
                
        public static IAsyncQueryableValue<bool> Any<TSource>(IAsyncQueryable<TSource> source, SerializableExpression serializablePredicate)
        {
            return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<decimal?> Average(this IAsyncQueryable<decimal?> source)
        {
            return Average<decimal?>(source);
        }
        public static IAsyncQueryableValue<decimal> Average(this IAsyncQueryable<decimal> source)
        {
            return Average<decimal>(source);
        }
        public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<double?> source)
        {
            return Average<double?>(source);
        }
        public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<double> source)
        {
            return Average<double>(source);
        }
        public static IAsyncQueryableValue<float?> Average(this IAsyncQueryable<float?> source)
        {
            return Average<float?>(source);
        }
        public static IAsyncQueryableValue<float> Average(this IAsyncQueryable<float> source)
        {
            return Average<float>(source);
        }
        public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<int?> source)
        {
            return Average<int?, double?>(source);
        }
        public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<int> source)
        {
            return Average<int, double>(source);
        }
        public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<long?> source)
        {
            return Average<long?, double?>(source);
        }
        public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<long> source)
        {
            return Average<long, double>(source);
        }
        private static IAsyncQueryableValue<T> Average<T>(this IAsyncQueryable<T> source)
        {
            return Average<T, T>(source);
        }
        private static IAsyncQueryableValue<TResult> Average<TSource, TResult>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters()[0].ParameterType == typeof(IQueryable<TSource>))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
        {
            return Average<TSource, decimal?>(source, selector);
        }
        public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
        {
            return Average<TSource, decimal>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
        {
            return Average<TSource, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
        {
            return Average<TSource, double>(source, selector);
        }
        public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
        {
            return Average<TSource, float?>(source, selector);
        }
        public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
        {
            return Average<TSource, float>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
        {
            return Average<TSource, int?, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
        {
            return Average<TSource, int, double>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
        {
            return Average<TSource, long?, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
        {
            return Average<TSource, long, double>(source, selector);
        }
        private static IAsyncQueryableValue<T> Average<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
        {
            return Average<TSource, T, T>(source, selector);
        }
        private static IAsyncQueryableValue<TResult> Average<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
        {
            return AverageAsyncQueryable<TSource, decimal?>(source, selector);
        }
        public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
        {
            return AverageAsyncQueryable<TSource, decimal>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
        {
            return AverageAsyncQueryable<TSource, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
        {
            return AverageAsyncQueryable<TSource, double>(source, selector);
        }
        public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
        {
            return AverageAsyncQueryable<TSource, float?>(source, selector);
        }
        public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
        {
            return AverageAsyncQueryable<TSource, float>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
        {
            return AverageAsyncQueryable<TSource, int?, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
        {
            return AverageAsyncQueryable<TSource, int, double>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
        {
            return AverageAsyncQueryable<TSource, long?, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
        {
            return AverageAsyncQueryable<TSource, long, double>(source, selector);
        }
        private static IAsyncQueryableValue<T> AverageAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
        {
            return AverageAsyncQueryable<TSource, T, T>(source, selector);
        }
        private static IAsyncQueryableValue<TResult> AverageAsyncQueryable<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> Cast<TResult>(this IAsyncQueryable source)
        {
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Cast").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
        }
                
        public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, T value)
        {
            return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(value, typeof(T)) }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, IAsyncQueryableValue<T> value)
        {
            return new AsyncQueryableValue<bool>(source.Context, Contains<T>(source.Expression, value.Expression), source.ParameterMode);
        }
        public static SerializableExpression Contains<T>(SerializableExpression source, SerializableExpression value)
        {
            return new SerializableMethodCallExpression(null, new[] { source, value }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)));
        }
                
        public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TSource> DefaultIfEmpty<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "DefaultIfEmpty" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TSource> Distinct<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> Except<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
        {
            return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Except" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TKey>>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
        {
            var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
            var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan?>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<string>, TResult>> resultSelector)
        {
            return GroupJoin<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        private static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
        {
            var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
            var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
        }
                
        public static IAsyncQueryable<TSource> Intersect<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
        {
            return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Intersect" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
        {
            var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
            var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, int, TResult>> resultSelector)
        {
            return Join<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, uint, TResult>> resultSelector)
        {
            return Join<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, short, TResult>> resultSelector)
        {
            return Join<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, ushort, TResult>> resultSelector)
        {
            return Join<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, byte, TResult>> resultSelector)
        {
            return Join<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, long, TResult>> resultSelector)
        {
            return Join<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, ulong, TResult>> resultSelector)
        {
            return Join<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, decimal, TResult>> resultSelector)
        {
            return Join<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, double, TResult>> resultSelector)
        {
            return Join<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, char, TResult>> resultSelector)
        {
            return Join<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime, TResult>> resultSelector)
        {
            return Join<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan, TResult>> resultSelector)
        {
            return Join<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, int?, TResult>> resultSelector)
        {
            return Join<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, uint?, TResult>> resultSelector)
        {
            return Join<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, short?, TResult>> resultSelector)
        {
            return Join<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, ushort?, TResult>> resultSelector)
        {
            return Join<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, byte?, TResult>> resultSelector)
        {
            return Join<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, long?, TResult>> resultSelector)
        {
            return Join<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, ulong?, TResult>> resultSelector)
        {
            return Join<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, decimal?, TResult>> resultSelector)
        {
            return Join<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, double?, TResult>> resultSelector)
        {
            return Join<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, char?, TResult>> resultSelector)
        {
            return Join<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime?, TResult>> resultSelector)
        {
            return Join<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan?, TResult>> resultSelector)
        {
            return Join<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, string, TResult>> resultSelector)
        {
            return Join<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
        }
        private static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
        {
            var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
            var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TSource> Max<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TResult> Max<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TSource> Min<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TResult> Min<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> OfType<TResult>(this IAsyncQueryable source)
        {
            if (source.Type == typeof(TResult))
                return (IAsyncQueryable<TResult>)source;
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("OfType").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
        }
                
        public static IAsyncQueryable<TSource> OrderBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> OrderByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> Reverse<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Reverse").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            if (selector.Body == selector.Parameters[0])
                return (IAsyncQueryable<TResult>)source;
            var memberInit = selector.Body as MemberInitExpression;
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
        }
                
        public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TResult>>> selector)
        {
            if (selector.Body == selector.Parameters[0])
                return (IAsyncQueryable<TResult>)source;
            var memberInit = selector.Body as MemberInitExpression;
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
        }
                
        public static IAsyncQueryable<IEnumerable<TResult>> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
        {
            if (selector.Body == selector.Parameters[0])
                return (IAsyncQueryable<IEnumerable<TResult>>)source;
            var memberInit = selector.Body as MemberInitExpression;
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryable<IEnumerable<TResult>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(IEnumerable<TResult>))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
        }
                
        public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
        {
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
        {
            var serializableSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
        {
            var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
        {
            var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
            ((SerializableLambdaExpression)serializableCollectionSelectorReference.Value).ReturnType = new SerializableType(typeof(IEnumerable<TCollection>));
            var serializableResultSelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
            return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source)
        {
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> Skip<TSource>(this IAsyncQueryable<TSource> source, int count)
        {
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Skip").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<decimal?> Sum(this IAsyncQueryable<decimal?> source)
        {
            return Sum<decimal?>(source);
        }
        public static IAsyncQueryableValue<decimal> Sum(this IAsyncQueryable<decimal> source)
        {
            return Sum<decimal>(source);
        }
        public static IAsyncQueryableValue<double?> Sum(this IAsyncQueryable<double?> source)
        {
            return Sum<double?>(source);
        }
        public static IAsyncQueryableValue<double> Sum(this IAsyncQueryable<double> source)
        {
            return Sum<double>(source);
        }
        public static IAsyncQueryableValue<float?> Sum(this IAsyncQueryable<float?> source)
        {
            return Sum<float?>(source);
        }
        public static IAsyncQueryableValue<float> Sum(this IAsyncQueryable<float> source)
        {
            return Sum<float>(source);
        }
        public static IAsyncQueryableValue<int?> Sum(this IAsyncQueryable<int?> source)
        {
            return Sum<int?>(source);
        }
        public static IAsyncQueryableValue<int> Sum(this IAsyncQueryable<int> source)
        {
            return Sum<int>(source);
        }
        public static IAsyncQueryableValue<long?> Sum(this IAsyncQueryable<long?> source)
        {
            return Sum<long?>(source);
        }
        public static IAsyncQueryableValue<long> Sum(this IAsyncQueryable<long> source)
        {
            return Sum<long>(source);
        }
        private static IAsyncQueryableValue<T> Sum<T>(this IAsyncQueryable<T> source)
        {
            return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters()[0].ParameterType == typeof(IQueryable<T>))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
        {
            return Sum<TSource, decimal?>(source, selector);
        }
        public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
        {
            return Sum<TSource, decimal>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
        {
            return Sum<TSource, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
        {
            return Sum<TSource, double>(source, selector);
        }
        public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
        {
            return Sum<TSource, float?>(source, selector);
        }
        public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
        {
            return Sum<TSource, float>(source, selector);
        }
        public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
        {
            return Sum<TSource, int?>(source, selector);
        }
        public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
        {
            return Sum<TSource, int>(source, selector);
        }
        public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
        {
            return Sum<TSource, long?>(source, selector);
        }
        public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
        {
            return Sum<TSource, long>(source, selector);
        }
        private static IAsyncQueryableValue<T> Sum<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
        {
            return SumAsyncQueryable<TSource, decimal?>(source, selector);
        }
        public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
        {
            return SumAsyncQueryable<TSource, decimal>(source, selector);
        }
        public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
        {
            return SumAsyncQueryable<TSource, double?>(source, selector);
        }
        public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
        {
            return SumAsyncQueryable<TSource, double>(source, selector);
        }
        public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
        {
            return SumAsyncQueryable<TSource, float?>(source, selector);
        }
        public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
        {
            return SumAsyncQueryable<TSource, float>(source, selector);
        }
        public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
        {
            return SumAsyncQueryable<TSource, int?>(source, selector);
        }
        public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
        {
            return SumAsyncQueryable<TSource, int>(source, selector);
        }
        public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
        {
            return SumAsyncQueryable<TSource, long?>(source, selector);
        }
        public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
        {
            return SumAsyncQueryable<TSource, long>(source, selector);
        }
        private static IAsyncQueryableValue<T> SumAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
            return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
        }
                
        public static IAsyncQueryable<TSource> Take<TSource>(this IAsyncQueryable<TSource> source, int count)
        {
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Take").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> ThenBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> ThenByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            var serializableKeySelectorReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
            return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> Union<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
        {
            return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Union" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
        }
                
        public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return Where(source, serializablePredicateReference.Value);
        }
                
        public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
        {
            var serializablePredicateReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
            return Where(source, serializablePredicateReference.Value);
        }
                
        public static IAsyncQueryable<TSource> Where<TSource>(IAsyncQueryable<TSource> source, SerializableExpression predicate)
        {
            return CreateAsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, predicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Where" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
                
                
        public static Expression<Func<T, bool>> BuildOr<T>(IEnumerable<Expression<Func<T, bool>>> exps)
        {
            if (exps == null || !exps.Any())
                return Expression.Lambda<Func<T, bool>>(Expression.Constant(true, typeof(bool)), Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N")));
            var parameterExpression = Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N"));
            return Expression.Lambda<Func<T, bool>>(exps.Select(e => e.ReplaceBodyParameter(parameterExpression)).Aggregate((e1, e2) => Expression.OrElse(e1, e2)), parameterExpression);
        }
                
                
                
                
        public static IAsyncQueryable<TSource> Include<TSource, TInclude>(IAsyncQueryable<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
        {
            return CreateAsyncQueryable<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> Include<TSource, TInclude>(IAsyncQueryableValue<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
        {
            return CreateAsyncQueryableValue<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
        }
            
        public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneToMany<OneT, OneT, ManyT>(source, manyEntitySet, exp, anyExp, queryTransform, fkTest, getTrackableCollection);
        }
            
        public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
                {
                    var include = new AsyncQueryableInclude();
                    var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
                    IAsyncQueryableBase subQuery;
                    Func<object, object[], MergeOption, object> load;
                    if (onesQueryAsAsyncQueryable == null)
                    {
                        subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                        load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
                    }
                    else
                    {
                        subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), manyEntitySet, anyExp, ref queryTransform);
                        if (queryTransform == null || queryTransform.Body is ParameterExpression)
                        {
                            string path = ((MemberExpression)exp.Body).Member.Name;
                            include.Path = path;
                        }
                        load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                    }
                    include.Queries = new IAsyncQueryableBase[] { subQuery };
                    include.Load = load;
                    return include;
                });
        }
                
        public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection);
        }
                
        public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                if (onesQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), queryTransform);
                    load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
                }
                else
                {
                    subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), exp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                }
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, Expression<ExpressionT> queryTransform)
            where QueryT : IAsyncQueryableBase
        {
            return CreateQuery<QueryT, ExpressionT>(getQuery, ref queryTransform);
        }
                
        private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, ref Expression<ExpressionT> queryTransform)
            where QueryT : IAsyncQueryableBase
        {
            var includeExpressionVisitor = new IncludeExpressionVisitor<QueryT>();
            queryTransform = (Expression<ExpressionT>)includeExpressionVisitor.Visit(queryTransform);
            var value = getQuery(queryTransform);
            foreach (var includeAction in includeExpressionVisitor.IncludeActions)
                value = includeAction(value);
            return value;
        }
        
        private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, ManyT, bool>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
        {
            var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
            var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
            var serializableExpReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
            var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
            var serializableExp = Where(manyEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
            {
                switch (anyLambda.Parameters.IndexOf(spe))
                {
                    case 0:
                        return oParameter;
                    case 1:
                        return mParameter;
                    default:
                        throw new InvalidOperationException();
                }
            })), ExpressionType.Quote, typeof(Expression<Func<OneT, bool>>))).Expression));
            return CreateQuery(qt => AddTransformExp<ManyT>(source, qt, serializableExp.Expression), queryTransform);
        }
        
        private static IAsyncQueryable<T> AddTransformExp<T>(IAsyncQueryable source, LambdaExpression qt, SerializableExpression serializableExp)
        {
            MethodCallExpression qtMethodCall;
            if (qt != null && (qtMethodCall = qt.Body as MethodCallExpression) != null)
            {
                var serializableReference = new Reference<SerializableExpression>();
                new SerializableExpressionBuilder(serializableReference, source.ParameterMode, new Dictionary<ParameterExpression, SerializableParameterExpression>(), source.Context, p => p == qt.Parameters[0] ? serializableExp : null) { UseQueryable = true }.Visit(qtMethodCall);
                var serializableMethodCallExpression = (SerializableMethodCallExpression)serializableReference.Value;
                serializableExp = serializableMethodCallExpression;
            }
            return CreateAsyncQueryable<T>(source.Context, serializableExp, source.ParameterMode);
        }
        
        private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
        {
            return CreateQuery(qt => CreateAsyncQueryable<ManyT>(source.Context, source.RemoveSelectFromSource().Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
        }
    
        private static IAsyncQueryableValue<ToTResult> CreateOneToOne<FromBaseT, FromT, ToT, ToTResult>(IAsyncQueryableValue<FromBaseT> source, Expression<Func<FromT, ToT>> exp, Func<IAsyncQueryable<ToT>, IAsyncQueryable<ToTResult>> queryTransform)
            where FromT : FromBaseT
        {
            var sourceValue = source.RemoveSelectFromSource();
            var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<FromBaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<FromT>();
            return CreateAsyncQueryableValue<ToTResult>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { queryTransform(baseQuery.Select(exp)).Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(ToTResult))), source.ParameterMode);
        }
    
        private static IAsyncQueryable<IEnumerable<ToTResult>> CreateOneToMany<FromBaseT, FromT, ToT, ToTResult>(IAsyncQueryableValue<FromBaseT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Func<IAsyncQueryable<IEnumerable<ToT>>, IAsyncQueryable<IEnumerable<ToTResult>>> queryTransform)
            where FromT : FromBaseT
        {
            var sourceValue = source.RemoveSelectFromSource();
            var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<FromBaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<FromT>();
            switch (method.Name)
            {
                case "Last":
                case "LastOrDefault":
                    throw new NotImplementedException("Last and LastOrDefault are not supported here. Use OrderByDescending().First() instead");
            }
            return CreateAsyncQueryable<IEnumerable<ToTResult>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { queryTransform(baseQuery.Select(exp)).Expression, new SerializableConstantExpression(1, typeof(int)) }, typeof(Queryable).GetMethod("Take").GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ToTResult>))), source.ParameterMode);
        }
    
        private static SerializableExpression AddOfType<BaseT, T>(IAsyncQueryableValue<BaseT> source)
            where T : BaseT
        {
            if (typeof(BaseT) == typeof(T))
                return source.Expression;
            var sourceValue = source.RemoveSelectFromSource();
            var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<BaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<T>();
            return new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { baseQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)));
        }
                
        private static IAsyncQueryable<FromT> CreateToOne<FromT>(IAsyncQueryableBase source, SerializableMethodCallExpression serializableMethodCallExpression, out MethodInfo method)
        {
            switch (serializableMethodCallExpression.MemberName)
            {
                case "First":
                case "FirstOrDefault":
                case "Single":
                case "SingleOrDefault":
                case "Last":
                case "LastOrDefault":
                    var baseQuery = CreateAsyncQueryable<FromT>(source.Context, serializableMethodCallExpression.Parameters[0], source.ParameterMode);
                    switch (serializableMethodCallExpression.Parameters.Count)
                    {
                        case 1:
                            method = serializableMethodCallExpression.Method;
                            break;
                        case 2:
                            method = serializableMethodCallExpression.Method.DeclaringType.GetMethods().First(m => m.Name == serializableMethodCallExpression.Method.Name && m.GetParameters().Length == 1);
                            baseQuery = Where(baseQuery, serializableMethodCallExpression.Parameters[1]);
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                    return baseQuery.RemoveSelectFromSource();
                default:
                    throw new NotImplementedException();
            }
        }
                
        private static IEnumerable<ManyT> IncludeOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        	if (mergeOption == MergeOption.NoTracking)
        	{
        		var manyArray = many.ToArray();
        		var ones = ((IEnumerable<object>)oneValues).Cast<OneT>();
         		foreach (var one in ones)
        		{
        			for (int mi = 0; mi < manyArray.Length; mi++)
        			{
        				var m = manyArray[mi];
        				if (fkTest(one, m))
        				{
        					getTrackableCollection(one).Attach(m);
        				}
        			}
        		}
        	}
        
        	return many;
        }
                
        public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
        }
                
        public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                subQuery = CreateQuery(qt => CreateOneToMany((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))).SelectMany(e => e), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
        }
                
        public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static object IncludeOneOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            var one = (OneT)oneValues;
            if (one == null)
                return null;
            var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
            if (mergeOption == MergeOption.NoTracking || manyToMany)
            {
        		foreach (var manyElt in many)
        		{
        			getTrackableCollection(one).Attach(manyElt);
        		}
        	}
        
            return many;
        }
                
        public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
        }
                
        public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                subQuery = CreateManyOneToMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeManyOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
            where OneT : OneBaseT
        {
            return CreateQuery(qt =>
            {
                var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
                if (qt != null)
                    exp = Expression.Lambda<Func<OneT, IEnumerable<ManyT>>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, exp), selectParameter));
                return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
            }, ref queryTransform);
        }
                
        private static object IncludeManyOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
        	var value = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        	if (mergeOption == MergeOption.NoTracking)
        	{
        		object oneValue = ((IEnumerable<object>)oneValues).Cast<OneT>();
        		var ones = ((IEnumerable<object>)oneValue).Cast<OneT>();
        		var manyArray = value.ToArray();
        		foreach (var one in ones)
        		{
        			for (int mi = 0; mi < manyArray.Length; mi++)
        			{
        				var m = manyArray[mi];
        				if (fkTest(one, m))
        				{
        					getTrackableCollection(one).Attach(m);
        				}
        			}
        		}
        	}
        
        	return value;
        }
                
        public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToOneMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyOneToOneMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
        }
                
        public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                subQuery = CreateManyOneToOneMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeManyOneToOneMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
            where OneT : OneBaseT
        {
            return CreateQuery(qt =>
            {
                var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
                var expOne = Expression.Lambda<Func<OneT, ManyT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, expOne), selectParameter));
                return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
            }, ref queryTransform);
        }
                
        private static object IncludeManyOneToOneMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
        	var many = ((IEnumerable<object>)manyValues).Cast<ManyT>();
        	if (mergeOption == MergeOption.NoTracking)
        	{
        		var ones = ((IEnumerable<object>)oneValues).Cast<OneT>();
        		var manyArray = many.ToArray();
        		foreach (var one in ones)
        		{
        			for (int mi = 0; mi < manyArray.Length; mi++)
        			{
        				var m = manyArray[mi];
        				if (fkTest(one, m))
        				{
        					getTrackableCollection(one).Attach(m);
        				}
        			}
        		}
        	}
        
        	return many;
        }
                
        public static IAsyncQueryable<ManyT> IncludeManyToOne<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyToOne<ManyT, ManyT, OneT>(source, onesEntitySet, exp, anyExp, queryTransform, fkTest, setOne);
        }
                
        public static IAsyncQueryable<ManyBaseT> IncludeManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryable<ManyBaseT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where ManyBaseT : IEntity
            where ManyT : ManyBaseT
            where OneT : IEntity
        {
            return Include<ManyBaseT, OneT>(source, manyQuery =>
            {
                var include = new AsyncQueryableInclude();
                var manyQueryAsAsyncQueryable = manyQuery as IAsyncQueryable<ManyBaseT>;
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                if (manyQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<ManyBaseT>)manyQuery), exp, q => q), queryTransform);
                    load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
                }
                else
                {
                    subQuery = CreateManyToOneQuery(manyQueryAsAsyncQueryable.OfType<ManyT>(), onesEntitySet, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (manyValues, oneValues, mergeOption) => IncludeManyToOne(manyValues, oneValues, mergeOption, fkTest, setOne);
                }
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static IAsyncQueryable<OneT> CreateManyToOneQuery<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT, bool>> exp, ref Expression<Func<OneT, OneT>> queryTransform)
        {
            var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
            var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
            var serializableExpReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
            var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
            var serializableExp = Where(onesEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
                {
                    switch (anyLambda.Parameters.IndexOf(spe))
                    {
                        case 0:
                            return mParameter;
                        case 1:
                            return oParameter;
                        default:
                            throw new InvalidOperationException();
                    }
                })), ExpressionType.Quote, typeof(Expression<Func<ManyT, bool>>))).Expression));
            return CreateQuery(qt => AddTransformExp<OneT>(source, qt, serializableExp.Expression), queryTransform);
        }
                
        private static object IncludeManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
        	var ones = ((IEnumerable<object>)oneValues[0]).Cast<OneT>();
        	if (mergeOption == MergeOption.NoTracking)
        	{
        		var onesArray = ones.Where(e => e != null).ToArray();
        		var manyArray = ((IEnumerable<object>)manyValues).Cast<ManyT>().ToArray();
        		for (int i = 0; i < manyArray.Length; i++)
        		{
        			var one = onesArray.FirstOrDefault(e => fkTest(manyArray[i], e));
        			if (one != null)
        			{
        				manyArray[i].IsInitializingRelationships = true;
        				setOne(manyArray[i], one);
        				manyArray[i].IsInitializingRelationships = false;
        			}
        		}
        
        	}
        
        	return ones;
        }
                
        private static object IncludeOneManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            OneT one = (OneT)oneValues[0];
            if (mergeOption == MergeOption.NoTracking)
            {
                if (manyValues == null)
                    return null;
                ManyT many = (ManyT)manyValues;
                if (one != null)
                {
                    many.IsInitializingRelationships = true;
                    setOne(many, one);
                    many.IsInitializingRelationships = false;
                }
            }
            return one;
        }
                
        public static IAsyncQueryableValue<ManyT> IncludeOneManyToOne<ManyT, OneT>(IAsyncQueryableValue<ManyT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneManyToOne<ManyT, ManyT, OneT>(source, exp, queryTransform, setOne);
        }
                
        public static IAsyncQueryableValue<ManyBaseT> IncludeOneManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryableValue<ManyBaseT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : ManyBaseT
            where ManyBaseT : IEntity
        {
            return Include<ManyBaseT, OneT>(source, manyQuery =>
            {
                var include = new AsyncQueryableInclude();
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<ManyBaseT>)manyQuery, exp, q => q), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                
        public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : IEntity
            where ToT : IEntity
        {
            return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toEntitySet, exp, getCollectionExp, anyExp, queryTransform, getKeysQuery, fromFkTest, toFkTest, getTrackableCollection);
        }
                
        public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : FromBaseT
            where FromBaseT : IEntity
            where ToT : IEntity
        {
            return Include<FromBaseT, ToT>(source, fromQuery =>
                {
                    var include = new AsyncQueryableInclude();
                    var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
                    IAsyncQueryableBase toQuery;
                    Func<object, object[], MergeOption, object> load;
                    if (fromBaseQueryAsAsyncQueryable == null)
                    {
                        toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                        load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                        return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
                    }
                    var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
                    toQuery = CreateManyToManyQuery(fromQueryAsAsyncQueryable, toEntitySet, exp, getCollectionExp, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable);
                    if (queryTransform != null)
                    {
                        var selectManyCollectionSelectorExpression = (SerializableLambdaExpression)((SerializableMethodCallExpression)keysQuery.Expression).Parameters[1];
                        var serializableCollectionSelectorReferenceTransform = new Reference<SerializableExpression>();
                        new SerializableExpressionBuilder(serializableCollectionSelectorReferenceTransform, source.ParameterMode, source.Context).Visit(queryTransform);
                        var queryTransformLambda = (SerializableLambdaExpression)serializableCollectionSelectorReferenceTransform.Value;
                        selectManyCollectionSelectorExpression.Body = queryTransformLambda.ReplaceBodyParameter(selectManyCollectionSelectorExpression.Body);
                    }
                    load = (fromValues, toValues, mergeOption) => IncludeManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                    include.Queries = new IAsyncQueryableBase[] { toQuery, keysQuery.RemoveSelectFromSource() };
                    include.Load = load;
                    return include;
                });
        }
                
        private static IAsyncQueryable<ToT> CreateManyToManyQuery<FromT, ToT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, ref Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform)
            where FromT : IEntity
            where ToT : IEntity
        {
            return CreateQuery(qt =>
                {
                    var toParameter = new SerializableParameterExpression { Name = "t" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ToT)) };
                    IAsyncQueryable<ToT> toQuery;
                    if (qt == null)
                    {
                        var fromParameter = new SerializableParameterExpression { Name = "f" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(FromT)) };
                        var serializableExpReference = new Reference<SerializableExpression>();
                        new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(anyExp);
                        var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
                        toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { fromParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
                        {
                            switch (anyLambda.Parameters.IndexOf(spe))
                            {
                                case 0:
                                    var serializablegetCollectionExpReference = new Reference<SerializableExpression>();
                                    new SerializableExpressionBuilder(serializablegetCollectionExpReference, source.ParameterMode, source.Context).Visit(getCollectionExp);
                                    var getSerializableCollectionExp = (SerializableLambdaExpression)serializablegetCollectionExpReference.Value;
                                    return getSerializableCollectionExp.ReplaceBodyParameter(fromParameter);
                                case 1:
                                    return toParameter;
                                default:
                                    throw new InvalidOperationException();
                            }
                        })), ExpressionType.Quote, typeof(Expression<Func<ToT, bool>>))).Expression));
                    }
                    else
                        toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Contains<ToT>(source.Select(exp).Select(qt).SelectMany(e => e).Expression, toParameter)));
                    return CreateAsyncQueryable<ToT>(source.Context, toQuery.Expression, source.ParameterMode);
                }, ref queryTransform);
        }
                
        public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : IEntity
            where ToT : class, IEntity
        {
            return IncludeManyToOneMany<FromT, FromT, ToT, KeysT>(source, exp, queryTransform, getKeysQuery, getTo, getFromKey, getTrackableCollection);
        }
                
        public static IAsyncQueryable<FromBaseT> IncludeManyToOneMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : FromBaseT
            where FromBaseT : IEntity
            where ToT : class, IEntity
        {
            return Include<FromBaseT, ToT>(source, fromQuery =>
            {
                var include = new AsyncQueryableInclude();
                var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
                IAsyncQueryableBase toQuery;
                Func<object, object[], MergeOption, object> load;
                if (fromBaseQueryAsAsyncQueryable == null)
                {
                    toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => q.Select(qt)), queryTransform);
                    load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
                }
                var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
                toQuery = CreateQuery(qt => CreateAsyncQueryable<ToT>(source.Context, fromQueryAsAsyncQueryable.Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                ToT toT = null;
                var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable, toT);
                var select = (SerializableMethodCallExpression)keysQuery.Expression;
                var selectLambda = (SerializableLambdaExpression)select.Parameters[1];
                var keysCtor = (SerializableConstructorExpression)((SerializableLambdaExpression)select.Parameters[1]).Body;
                var keysCtorToArg = keysCtor.Arguments.Last();
                var expSerializableExpressionReference = new Reference<SerializableExpression>();
                new SerializableExpressionBuilder(expSerializableExpressionReference, source.ParameterMode, source.Context).Visit(exp);
                var expLambda = (SerializableLambdaExpression)expSerializableExpressionReference.Value;
                var queryTransformSerializableExpressionReference = new Reference<SerializableExpression>();
                new SerializableExpressionBuilder(queryTransformSerializableExpressionReference, source.ParameterMode, source.Context).Visit(queryTransform);
                var queryTransformLambdaSerializableExpression = (SerializableLambdaExpression)queryTransformSerializableExpressionReference.Value;
                keysCtorToArg = queryTransformLambdaSerializableExpression.ReplaceBodyParameter(expLambda.ReplaceBodyParameter(selectLambda.Parameters[0]));
                keysCtor.Arguments[keysCtor.Arguments.Count - 1] = keysCtorToArg;
                
                keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQuery.Expression, keysQuery.ParameterMode, toQuery.Includes);
                
                load = (fromValues, toValues, mergeOption) => IncludeManyToOneMany<FromT, ToT, KeysT>(fromValues, toValues, getTo, getFromKey, getTrackableCollection);
                include.Queries = new IAsyncQueryableBase[] { keysQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static object IncludeManyToOneMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        {
            var keys = ((IEnumerable<object>)toValues[0]).Cast<KeysT>();
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToArray();
            var tos = new List<ToT>();
            foreach (var key in keys)
            {
                var to = getTo(key);
                if (to != null)
                {
                    getTrackableCollection(froms.FirstOrDefault(f => getFromKey(key, f))).Attach(getTo(key));
                    tos.Add(to);
                }
            }
            return tos;
        }
                
        public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : IEntity
        {
            return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toQuery, getKeysQuery, getKeysQueryForOne, fromFkTest, toFkTest, getTrackableCollection);
        }
                
        public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : class, FromBaseT
            where FromBaseT : class, IEntity
            where ToT : IEntity
        {
            if (source.Context != toQuery.Context)
                throw new InvalidOperationException();
            return Include<FromBaseT, ToT>(source, fromQuery =>
            {
                var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
                Func<object, object[], MergeOption, object> load;
                IAsyncQueryable<KeysT> keysQuery;
                if (fromBaseQueryAsAsyncQueryable == null)
                {
                    keysQuery = CreateOneManyToManyKeysQuery(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQueryForOne);
                    load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
                }
                keysQuery = getKeysQuery(fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>(), toQuery.RemoveSelectFromSource());
                load = (fromValues, toValues, mergeOption) => IncludeManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
        }
                
        public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            if (source.Context != toQuery.Context)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
            {
                Func<object, object[], MergeOption, object> load;
                IAsyncQueryableBase keysQuery;
                var fromQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromT>;
                if (fromQueryAsAsyncQueryable == null)
                {
                    keysQuery = CreateOneManyToOneManyKeysQuery(((IAsyncQueryableValue<FromT>)fromQuery).RemoveSelectFromSource(), toQuery, getKeysQuery);
                    load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
                }
                keysQuery = CreateManyToOneManyKeysQuery(fromQueryAsAsyncQueryable.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
        }
                
        public static IAsyncQueryableValue<FromT> IncludeOneManyToMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : IEntity
        {
            if (source.Context != toQuery.Context)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
                {
                    var keysQuery = CreateOneManyToManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                    Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
                });
        }
                
        public static IAsyncQueryableValue<FromT> IncludeOneManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            if (source.Context != toQuery.Context)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
                {
                    var keysQuery = CreateOneManyToOneManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                    Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
                });
        }
                
        private static IAsyncQueryable<KeysT> CreateOneManyToManyKeysQuery<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryableValue<FromBaseT> fromQuery, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery)
            where FromT : class, FromBaseT
            where FromBaseT : class, IEntity
            where ToT : IEntity
        {
            FromT fromT = null;
            var keysQuery = getKeysQuery(fromT, toQuery);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
            {
                if (constant.Value == fromT)
                    return new RemoveSelect().Visit(AddOfType<FromBaseT, FromT>(fromQuery));
                return constant;
            });
            return CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
        }
                
        private static IAsyncQueryable<KeysT> CreateManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryable<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
            where FromT : IEntity
            where ToT : class, IEntity
        {
            ToT toT = null;
            var keysQuery = getKeysQuery(fromQuery.RemoveSelectFromSource(), toT);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
            {
                if (constant.Value == toT)
                    return toQuery.Expression;
                return constant;
            });
            keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
            return keysQuery;
        }
                
        private static IAsyncQueryableValue<KeysT> CreateOneManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            fromQuery = fromQuery.RemoveSelectFromSource();
            MethodInfo method;
            var fromQueryAsAsyncQueryable = CreateToOne<FromT>(fromQuery, (SerializableMethodCallExpression)fromQuery.Expression, out method);
            ToT toT = null;
            var keysQuery = getKeysQuery(CreateAsyncQueryable<FromT>(fromQuery.Context, fromQueryAsAsyncQueryable.Expression, fromQuery.ParameterMode), toT);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
            {
                if (constant.Value == toT)
                    return toQuery.Expression;
                return constant;
            });
            return CreateAsyncQueryableValue<KeysT>(keysQuery.Context, new SerializableMethodCallExpression(null, new[] { keysQueryExpression }, method.MakeGenericMethod(typeof(KeysT))), keysQuery.ParameterMode);
        }
                
        private static object IncludeManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        {
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToArray();
            var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToArray();
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                FromT fromValue = froms.FirstOrDefault(f => fromFkTest(key, f));
                ToT toValue;
                if (fromValue != null && (toValue = tos.FirstOrDefault(t => toFkTest(key, t))) != null)
                    getTrackableCollection(fromValue).Attach(toValue);
            }
            return tos;
        }
                
        private static object IncludeManyToOneManyTask<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        {
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToArray();
            var to = (ToT)toValues[0];
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                var @from = froms.FirstOrDefault(f => fromFkTest(key, f));
                if (@from != null && toFkTest(key, to))
                    getTrackableCollection(@from).Attach(to);
            }
            return to;
        }
                
        private static object IncludeOneManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        {
            var @from = (FromT)fromValues;
            var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToArray();
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                var toValue = tos.FirstOrDefault(t => toFkTest(key, t));
                if (toValue != null && fromFkTest(key, @from))
                    getTrackableCollection(@from).Attach(toValue);
            }
            return tos;
        }
                
        private static object IncludeOneManyToOneMany<FromT, ToT>(object fromValues, object[] toValues, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        {
            var fromValue = (FromT)fromValues;
            var toValue = (ToT)toValues[0];
            getTrackableCollection(fromValue).Attach(toValue);
            return toValue;
        }
                
        public static IAsyncQueryableValue<IEnumerable<FromT>> IncludeManyOneToOne<FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : IEntity
            where ToT : IEntity
        {
            return IncludeManyOneToOne<FromT, FromT, ToT>(source, exp, queryTransform, fkTest, setTo);
        }
                
        public static IAsyncQueryableValue<IEnumerable<FromBaseT>> IncludeManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : FromBaseT
            where FromBaseT : IEntity
            where ToT : IEntity
        {
            return Include<IEnumerable<FromBaseT>, ToT>(source, fromQuery =>
            {
                var include = new AsyncQueryableInclude();
                var toQuery = CreateManyOneToOne(((IAsyncQueryableValue<IEnumerable<FromBaseT>>)source).RemoveSelectFromSource(), exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeManyOneToOne(fromValues, toValues, mergeOption, fkTest, setTo);
                include.Queries = new IAsyncQueryableBase[] { toQuery };
                include.Load = load;
                return include;
            });
        }
                
        private static IAsyncQueryableValue<IEnumerable<ToT>> CreateManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, ref Expression<Func<ToT, ToT>> queryTransform)
            where FromT : FromBaseT
        {
            source = source.RemoveSelectFromSource();
            return CreateQuery(qt =>
            {
                if (qt == null)
                    qt = e => e;
                var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<FromBaseT>>(source, serializableMethodCallExpression, out method).Select(fs => fs.OfType<FromT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<FromT>), "e" + Guid.NewGuid().ToString("N"));
                var expTo = Expression.Lambda<Func<FromT, ToT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<FromT>, IEnumerable<ToT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(ToT)), Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(FromT), typeof(ToT)), selectParameter, expTo)), selectParameter));
                return CreateAsyncQueryableValue<IEnumerable<ToT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ToT>))), source.ParameterMode);
            }, ref queryTransform);
        }
                
        private static object IncludeManyOneToOne<FromT, ToT>(object fromValues, object[] toValues, MergeOption mergeOption, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : IEntity
            where ToT : IEntity
        {
        	var tos = ((IEnumerable<object>)toValues).Cast<ToT>();
        	var froms = ((IEnumerable<object>)fromValues).Cast<FromT>();
        	if (mergeOption == MergeOption.NoTracking)
        	{
        		var tosArray = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToArray();
        		foreach (var from in froms)
        		{
        			for (int i = 0; i < tosArray.Length; i++)
        			{
        				if (tosArray[i] != null && fkTest(from, tosArray[i]))
        				{
        					tosArray[i].IsInitializingRelationships = true;
        					setTo(from, tosArray[i]);
        					tosArray[i].IsInitializingRelationships = false;
        				}
        			}
        		}
        	}
        
        	return tos;
        }
                
        private static IAsyncQueryable<T> RemoveSelectFromSource<T>(this IAsyncQueryable<T> source)
        {
            if (source == null)
                return null;
            return CreateAsyncQueryable<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        private static IAsyncQueryableValue<T> RemoveSelectFromSource<T>(this IAsyncQueryableValue<T> source)
        {
            if (source == null)
                return null;
            return CreateAsyncQueryableValue<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
        }
                
        public static IAsyncQueryable<TSource> CreateAsyncQueryable<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        {
            return new AsyncQueryable<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
        }
                
        public static IAsyncQueryableValue<TSource> CreateAsyncQueryableValue<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        {
            return new AsyncQueryableValue<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
        }
                
        public static IAsyncQueryable<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryable<QueryT> query)
        {
            return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
        }
                
        public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<OldT> query)
        {
            return ReplaceType<OldT, NewT, OldT, NewT>(query);
        }
                
        public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<NewT> query)
        {
            return ReplaceType<NewT, NewT, OldT, NewT>(query);
        }
                
        private static IAsyncQueryable<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryable<OldQueryT> query)
        {
            return CreateAsyncQueryable<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
        }
                
        public static IAsyncQueryableValue<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryableValue<QueryT> query)
        {
            return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
        }
                
        public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<OldT> query)
        {
            return ReplaceType<OldT, NewT, OldT, NewT>(query);
        }
                
        public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<NewT> query)
        {
            return ReplaceType<NewT, NewT, OldT, NewT>(query);
        }
                
        private static IAsyncQueryableValue<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryableValue<OldQueryT> query)
        {
            return CreateAsyncQueryableValue<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
        }
                
        public static T AsObject<T>(this IAsyncQueryableValue<T> asyncQueryableValue)
        {
            throw new InvalidOperationException("This method could only be used inside a LINQ To WAQS expression");
        }
                
        private class RemoveSelect : SerializableExpressionRewriter
        {
            protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
            {
                if (expression.MemberName == "Select" && expression.GenericArguments.Count == 2 && expression.GenericArguments[0].Type == expression.GenericArguments[1].Type && new[] { typeof(Queryable), typeof(Enumerable) }.Contains(expression.Method.DeclaringType))
                {
                    var lambda = (SerializableLambdaExpression)expression.Parameters[1];
                    var serializableMemberInit = lambda.Body as SerializableMemberInitExpression;
                    if (serializableMemberInit != null && serializableMemberInit.Setters.All(s =>
                        {
                            var propGet = s.Value as SerializablePropertyGetterExpression;
                            return propGet != null && propGet.Source == lambda.Parameters[0] && propGet.MemberName == s.MemberName;
                        }))
                        return expression.Parameters[0];
                }
                return base.VisitMethodCall(expression);
            }
        }
    }
}

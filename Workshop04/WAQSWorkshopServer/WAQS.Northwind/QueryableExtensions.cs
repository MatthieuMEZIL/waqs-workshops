//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using WAQS.Common;
using WAQS.Entities;

namespace WAQS.DAL.Interfaces
{
    public static class QueryableExtensions
    {
        private static Expression<Func<T1, TResult>> GetExpression<TSource, T1, TResult>(IWAQSQuery<TSource> source, Expression<Func<T1, TResult>> exp)
        {
            if (exp != null)
                exp = (Expression<Func<T1, TResult>>)source.ExpressionTransformation(exp);
            return exp;
        }
    
        private static Expression<Func<T1, T2, TResult>> GetExpression<TSource, T1, T2, TResult>(IWAQSQuery<TSource> source, Expression<Func<T1, T2, TResult>> exp)
        {
            if (exp != null)
                exp = (Expression<Func<T1, T2, TResult>>)source.ExpressionTransformation(exp);
            return exp;
        }
    
        public static bool All<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return Queryable.All(source, GetExpression(source, predicate));
        }
    
        public static bool Any<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return Queryable.Any(source, GetExpression(source, predicate));
        }
    
        public static decimal? Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, decimal?>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static decimal Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, decimal>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double? Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, double?>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, double>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static float? Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, float?>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static float Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, float>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double? Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, int?>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, int>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double? Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, long?>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static double Average<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, long>> selector)
        {
            return Queryable.Average(source, GetExpression(source, selector));
        }
    
        public static IWAQSQuery<TResult> Cast<TResult>(this IWAQSQuery source)
        {
            return ApplyIncludesAndWiths(source, Queryable.Cast<TResult>(source));
        }
    
        public static int Count<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return Queryable.Count(source, GetExpression(source, predicate));
        }
                                                
        public static IWAQSQuery<TSource> DefaultIfEmpty<TSource>(this IWAQSQuery<TSource> source)
        {
            return ApplyIncludesAndWiths(source, Queryable.DefaultIfEmpty(source));
        }
                                                
        public static IWAQSQuery<TSource> Distinct<TSource>(this IWAQSQuery<TSource> source)
        {
            return ApplyIncludesAndWiths(source, Queryable.Distinct(source));
        }
                                                
        public static IWAQSQuery<TSource> Except<TSource>(this IWAQSQuery<TSource> source1, IWAQSQuery<TSource> source2)
        {
            return (IWAQSQuery<TSource>)Queryable.Except(source1, source2);
        }
                        
        public static TSource First<TSource>(this IWAQSQuery<TSource> source)
        {
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Take(1);
            return Queryable.First(source);
        }
                        
        public static TSource First<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            predicate = GetExpression(source, predicate);
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Where(predicate).Take(1);
            return Queryable.First(source, predicate);
        }
                        
        public static TSource FirstOrDefault<TSource>(this IWAQSQuery<TSource> source)
        {
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Take(1);
            return Queryable.FirstOrDefault(source);
        }
                        
        public static TSource FirstOrDefault<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            predicate = GetExpression(source, predicate);
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Where(predicate).Take(1);
            return Queryable.FirstOrDefault(source, predicate);
        }
                                                
        public static IWAQSQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            return CreateWAQSQuery<IGrouping<TKey, TSource>>(source.DataContext, Queryable.GroupBy(source, GetExpression(source, keySelector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
    
        public static IWAQSQuery<TResult> GroupBy<TSource, TKey, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector)
        {
            return CreateWAQSQuery<TResult>(source.DataContext, Queryable.GroupBy(source, GetExpression(source, keySelector), GetExpression(source, resultSelector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
    
        public static IWAQSQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector)
        {
            return CreateWAQSQuery<IGrouping<TKey, TElement>>(source.DataContext, Queryable.GroupBy(source, GetExpression(source, keySelector), GetExpression(source, elementSelector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
    
        public static IWAQSQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector)
        {
            return CreateWAQSQuery<TResult>(source.DataContext, Queryable.GroupBy(source, GetExpression(source, keySelector), GetExpression(source, elementSelector), GetExpression(source, resultSelector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
                                                
        public static IWAQSQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IWAQSQuery<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
        {
            return CreateWAQSQuery<TResult>(outer.DataContext, Queryable.GroupJoin(outer, inner, GetExpression(outer, outerKeySelector), GetExpression(outer, innerKeySelector), GetExpression(outer, resultSelector)), outer.AsyncQueryProviderFactory, outer.ExpressionTransformation);
        }
                                                    
        public static IWAQSQuery<TSource> Intersect<TSource>(this IWAQSQuery<TSource> source1, IWAQSQuery<TSource> source2)
        {
            return CreateWAQSQuery<TSource>(source1.DataContext, Queryable.Intersect(source1, source2), source1.AsyncQueryProviderFactory, source1.ExpressionTransformation);
        }
                                                    
        public static IWAQSQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this IWAQSQuery<TOuter> outer, IWAQSQuery<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
        {
            return CreateWAQSQuery<TResult>(outer.DataContext, Queryable.Join(outer, inner, GetExpression(outer, outerKeySelector), GetExpression(inner, innerKeySelector), GetExpression(outer, resultSelector)), inner.AsyncQueryProviderFactory, inner.ExpressionTransformation);
        }
    
        public static long LongCount<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return Queryable.LongCount(source, GetExpression(source, predicate));
        }
    
        public static TResult Max<TSource, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            return Queryable.Max(source, GetExpression(source, selector));
        }
    
        public static TResult Min<TSource, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            return Queryable.Min(source, GetExpression(source, selector));
        }
    
        public static IWAQSQuery<TResult> OfType<TResult>(this IWAQSQuery source)
        {
            if (source.ElementType == typeof(TResult))
                return (IWAQSQuery<TResult>)source;
            return ApplyIncludesAndWiths(source, Queryable.OfType<TResult>(source));
        }
                                                    
        public static IWAQSQuery<TSource> OrderBy<TSource, TKey>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            return ApplyIncludesAndWiths(source, Queryable.OrderBy(source, GetExpression(source, keySelector)));
        }
                                                    
        public static IWAQSQuery<TSource> OrderByDescending<TSource, TKey>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            return ApplyIncludesAndWiths(source, Queryable.OrderByDescending(source, GetExpression(source, keySelector)));
        }
                                                    
        public static IWAQSQuery<TSource> Reverse<TSource>(this IWAQSQuery<TSource> source)
        {
            return ApplyIncludesAndWiths(source, Queryable.Reverse(source));
        }
                                                    
        public static IWAQSQuery<TResult> Select<TSource, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            if (selector.Body == selector.Parameters[0])
                return (IWAQSQuery<TResult>)source;
            return CreateWAQSQuery<TResult>(source.DataContext, Queryable.Select(source, GetExpression(source, selector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
                                                    
        public static IWAQSQuery<TResult> SelectMany<TSource, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
        {
            return CreateWAQSQuery<TResult>(source.DataContext, Queryable.SelectMany(source, GetExpression(source, selector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
                                                    
        public static IWAQSQuery<TResult> SelectMany<TSource, TCollection, TResult>(this IWAQSQuery<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
        {
            return CreateWAQSQuery<TResult>(source.DataContext, Queryable.SelectMany(source, GetExpression(source, collectionSelector), GetExpression(source, resultSelector)), source.AsyncQueryProviderFactory, source.ExpressionTransformation);
        }
                            
        public static TSource Single<TSource>(this IWAQSQuery<TSource> source)
        {
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Take(1);
            return Queryable.Single(source);
        }
                            
        public static TSource Single<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            predicate = GetExpression(source, predicate);
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Where(predicate).Take(1);
            return Queryable.Single(source, predicate);
        }
                            
        public static TSource SingleOrDefault<TSource>(this IWAQSQuery<TSource> source)
        {
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Take(1);
            return Queryable.SingleOrDefault(source);
        }
                            
        public static TSource SingleOrDefault<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            predicate = GetExpression(source, predicate);
            ((WAQSQueryProvider)source.Provider).CurrentQuery = source.Where(predicate).Take(1);
            return Queryable.SingleOrDefault(source, predicate);
        }
                                                    
        public static IWAQSQuery<TSource> Skip<TSource>(this IWAQSQuery<TSource> source, int count)
        {
            return ApplyIncludesAndWiths(source, Queryable.Skip(source, count));
        }
                                                    
        public static IWAQSQuery<TSource> Take<TSource>(this IWAQSQuery<TSource> source, int count)
        {
            return ApplyIncludesAndWiths(source, Queryable.Take(source, count));
        }
    
        public static decimal? Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, decimal?>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static decimal Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, decimal>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static double? Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, double?>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static double Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, double>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static float? Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, float?>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static float Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, float>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static int? Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, int?>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static int Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, int>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static long? Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, long?>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
    
        public static long Sum<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, long>> selector)
        {
            return Queryable.Sum(source, GetExpression(source, selector));
        }
                    
        public static IWAQSQuery<TSource> ThenBy<TSource, TKey>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            return ApplyIncludesAndWiths(source, Queryable.ThenBy(source, GetExpression(source, keySelector)));
        }
                                                    
        public static IWAQSQuery<TSource> ThenByDescending<TSource, TKey>(this IWAQSQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector)
        {
            return ApplyIncludesAndWiths(source, Queryable.ThenByDescending(source, GetExpression(source, keySelector)));
        }
                                                    
        public static IWAQSQuery<TSource> Union<TSource>(this IWAQSQuery<TSource> source1, IWAQSQuery<TSource> source2)
        {
            return CreateWAQSQuery<TSource>(source1.DataContext, Queryable.Union(source1, source2), source1.AsyncQueryProviderFactory, source1.ExpressionTransformation);
        }
                                                    
        public static IWAQSQuery<TSource> Where<TSource>(this IWAQSQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return ApplyIncludesAndWiths(source, Queryable.Where(source, GetExpression(source, predicate)));
        }
                                                
                                                
                                                
        public static Expression<Func<T, bool>> BuildOr<T>(IEnumerable<Expression<Func<T, bool>>> exps)
        {
            if (exps == null || !exps.Any())
                return Expression.Lambda<Func<T, bool>>(Expression.Constant(true, typeof(bool)), Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N")));
            var parameterExpression = Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N"));
            return Expression.Lambda<Func<T, bool>>(exps.Select(e => e.Body.ReplaceParameter(e.Parameters[0], parameterExpression)).Aggregate((e1, e2) => Expression.OrElse(e1, e2)), parameterExpression);
        }
                                                
                                                
                                                
        public static IWAQSQuery<TSource> Include<TSource, TInclude>(IWAQSQuery<TSource> source, params Func<IWAQSQueryBase, QueryableInclude>[] includes)
        {
            return CreateWAQSQuery<TSource>(source, source.QueryableIncludes == null ? includes : source.QueryableIncludes.Union(includes), source.WithSpecifications);
        }
                                    
        public static IWAQSQueryValue<TSource> Include<TSource, TInclude>(IWAQSQueryValue<TSource> source, params Func<IWAQSQueryBase, QueryableInclude>[] includes)
        {
            return CreateWAQSQueryValue<TSource>(source.WAQSQueryProvider, source.DataContext, source.Expression, source.QueryableIncludes.Union(includes), source.WithSpecifications);
        }
        
        public static IWAQSQuery<OneT> IncludeOneToMany<OneT, ManyT>(IWAQSQuery<OneT> source, IWAQSQuery<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : class, IEntity
            where ManyT : class, IEntity
        {
            return IncludeOneToMany<OneT, OneT, ManyT>(source, manyEntitySet, exp, anyExp, queryTransform, fkTest, getTrackableCollection);
        }
        
        public static IWAQSQuery<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IWAQSQuery<OneBaseT> source, IWAQSQuery<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : class, OneBaseT
            where OneBaseT : class, IEntity
            where ManyT : class, IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                var onesQueryAsWAQSQuery = onesQuery as IWAQSQuery<OneBaseT>;
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                if (onesQueryAsWAQSQuery == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                    load = (oneValues, manyValues) => IncludeOneOneToMany(source.DataContext, oneValues, manyValues, getTrackableCollection);
                }
                else
                {
                    subQuery = CreateOneToManyQuery(onesQueryAsWAQSQuery.OfType<OneT>(), manyEntitySet, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (oneValues, manyValues) => IncludeOneToMany(oneValues, manyValues, fkTest, getTrackableCollection);
                }
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
        
        public static IWAQSQuery<OneT> IncludeOneToMany<OneT, ManyT>(IWAQSQuery<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : class, IEntity
            where ManyT : class, IEntity
        {
            return IncludeOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection);
        }
            
        public static IWAQSQuery<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IWAQSQuery<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : class, OneBaseT
            where OneBaseT : class, IEntity
            where ManyT : class, IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                var onesQueryAsAsyncQueryable = onesQuery as IWAQSQuery<OneBaseT>;
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                if (onesQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), queryTransform);
                    load = (oneValues, manyValues) => IncludeOneOneToMany(source.DataContext, oneValues, manyValues, getTrackableCollection);
                }
                else
                {
                    subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), exp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (oneValues, manyValues) => IncludeOneToMany(oneValues, manyValues, fkTest, getTrackableCollection);
                }
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, Expression<ExpressionT> queryTransform)
            where QueryT : IWAQSQueryBase
        {
            return CreateQuery<QueryT, ExpressionT>(getQuery, ref queryTransform);
        }
                                                
        private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, ref Expression<ExpressionT> queryTransform)
            where QueryT : IWAQSQueryBase
        {
            var includeExpressionVisitor = new IncludeExpressionVisitor<QueryT>();
            queryTransform = (Expression<ExpressionT>)includeExpressionVisitor.Visit(queryTransform);
            var value = getQuery(queryTransform);
            foreach (var includeAction in includeExpressionVisitor.IncludeActions)
                value = includeAction(value);
            return value;
        }
                                                
        private static IWAQSQuery<ManyT> CreateOneToManyQuery<OneT, ManyT>(IWAQSQuery<OneT> source, IWAQSQuery<ManyT> manyEntitySet, Expression<Func<OneT, ManyT, bool>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
        {
            var oParameter = Expression.Parameter(typeof(OneT), "o" + Guid.NewGuid().ToString("N"));
            var mParameter = Expression.Parameter(typeof(ManyT), "m" + Guid.NewGuid().ToString("N"));
            var query = Where(manyEntitySet, Expression.Lambda<Func<ManyT, bool>>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(OneT)), source.Expression, Expression.Lambda(exp.Body.ReplaceParameter(spe =>
            {
                switch (exp.Parameters.IndexOf(spe))
                {
                    case 0:
                        return oParameter;
                    case 1:
                        return mParameter;
                    default:
                        throw new InvalidOperationException();
                }
            }), oParameter)), mParameter));
            return CreateQuery(qt => qt == null ? query : (IWAQSQuery<ManyT>)query.Provider.CreateQuery<ManyT>(qt.Body.ReplaceParameter(qt.Parameters[0], query.Expression).UseQueryable()), ref queryTransform);
        }
        
        private static IWAQSQuery<ManyT> CreateOneToManyQuery<OneT, ManyT>(IWAQSQuery<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
        {
            return CreateQuery(qt => CreateWAQSQuery<ManyT>(source.DataContext, source.Select(exp).Select(qt), source.AsyncQueryProviderFactory, source.ExpressionTransformation), ref queryTransform);
        }                                        
        private static IWAQSQueryValue<ToTResult> CreateOneToOne<FromBaseT, FromT, ToT, ToTResult>(IWAQSQueryValue<FromBaseT> source, Expression<Func<FromT, ToT>> exp, Func<IWAQSQuery<ToT>, IWAQSQuery<ToTResult>> transformExp)
            where FromT : FromBaseT
        {
            var methodCallExpression = (MethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<FromBaseT>(source, methodCallExpression, out method).OfType<FromT>();
            return CreateWAQSQueryValue<ToTResult>(source.WAQSQueryProvider, source.DataContext, Expression.Call(methodCallExpression.Object, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(ToTResult)), new[] { transformExp(baseQuery.Select(exp)).Expression }));
        }
                                                
        private static IWAQSQuery<FromT> CreateToOne<FromT>(IWAQSQueryBase source, MethodCallExpression methodCallExpression, out MethodInfo method)
        {
            switch (methodCallExpression.Method.Name)
            {
                case "First":
                case "FirstOrDefault":
                case "Single":
                case "SingleOrDefault":
                case "Last":
                case "LastOrDefault":
                    IWAQSQuery<FromT> baseQuery = CreateWAQSQuery<FromT>((IWAQSQuery<FromT>)methodCallExpression.Arguments[0]);
                    switch (methodCallExpression.Arguments.Count)
                    {
                        case 1:
                            method = methodCallExpression.Method;
                            break;
                        case 2:
                            method = methodCallExpression.Method.DeclaringType.GetMethods().First(m => m.Name == methodCallExpression.Method.Name && m.GetParameters().Length == 1);
                            baseQuery = Where(baseQuery, (Expression<Func<FromT, bool>>)methodCallExpression.Arguments[1]);
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                    return baseQuery;
                default:
                    throw new NotImplementedException();
            }
        }
                                                
        private static IEnumerable<ManyT> IncludeOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        }
            
        public static IWAQSQueryValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IWAQSQueryValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : class, IEntity
            where ManyT : class, IEntity
        {
            return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
        }
            
        public static IWAQSQueryValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : class, OneBaseT
            where OneBaseT : class, IEntity
            where ManyT : class, IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues) => IncludeOneOneToMany(onesQuery.DataContext, oneValues, manyValues, getTrackableCollection, manyToMany);
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
            
        public static IWAQSQueryValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IWAQSQueryValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : class, IEntity
            where ManyT : class, IEntity
        {
            return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
        }
            
        public static IWAQSQueryValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : class, OneBaseT
            where OneBaseT : class, IEntity
            where ManyT : class, IEntity
        {
            return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues) => IncludeOneOneToMany(onesQuery.DataContext, oneValues, manyValues, getTrackableCollection, manyToMany);
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static object IncludeOneOneToMany<OneT, ManyT>(IDataContext context, object oneValues, object[] manyValues, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : class, IEntity
            where ManyT : class, IEntity
        {
            var one = (OneT)oneValues;
            if (one == null)
                return null;
            var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
            if (manyToMany)
                foreach (var manyElt in many)
                    getTrackableCollection(one).Attach(manyElt, context);
            return many;
        }
            
        public static IWAQSQueryValue<IEnumerable<OneT>> IncludeManyOneToMany<OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
        }
            
        public static IWAQSQueryValue<IEnumerable<OneBaseT>> IncludeManyOneToMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                subQuery = CreateManyOneToMany((IWAQSQueryValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues) => IncludeManyOneToMany(oneValues, manyValues, fkTest, getTrackableCollection);
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static IWAQSQueryValue<IEnumerable<ManyT>> CreateManyOneToMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
            where OneT : OneBaseT
        {
            return CreateQuery(qt =>
            {
                var methodCallExpression = (MethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<OneT>>(source, methodCallExpression, out method).Select(os => os.OfType<OneT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
                if (qt != null)
                    exp = Expression.Lambda<Func<OneT, IEnumerable<ManyT>>>(qt.Body.ReplaceParameter(qt.Parameters[0], exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, exp), selectParameter));
                return CreateWAQSQueryValue<IEnumerable<ManyT>>(source.WAQSQueryProvider, source.DataContext, Expression.Call(methodCallExpression.Object, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>)), manyQuery.Expression));
            }, ref queryTransform);
        }
                                                
        private static object IncludeManyOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        }
            
        public static IWAQSQueryValue<IEnumerable<OneT>> IncludeManyOneToOneMany<OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyOneToOneMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
        }
            
        public static IWAQSQueryValue<IEnumerable<OneBaseT>> IncludeManyOneToOneMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
            where OneT : OneBaseT
            where OneBaseT : IEntity
            where ManyT : IEntity
        {
            return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
            {
                var include = new QueryableInclude();
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                subQuery = CreateManyOneToOneMany((IWAQSQueryValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues) => IncludeManyOneToOneMany(oneValues, manyValues, fkTest, getTrackableCollection);
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static IWAQSQueryValue<IEnumerable<ManyT>> CreateManyOneToOneMany<OneBaseT, OneT, ManyT>(IWAQSQueryValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
            where OneT : OneBaseT
        {
            return CreateQuery(qt =>
            {
                var methodCallExpression = (MethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<OneT>>(source, methodCallExpression, out method).Select(os => os.OfType<OneT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
                var expOne = Expression.Lambda<Func<OneT, ManyT>>(qt.Body.ReplaceParameter(qt.Parameters[0], exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, expOne), selectParameter));
                return CreateWAQSQueryValue<IEnumerable<ManyT>>(source.WAQSQueryProvider, source.DataContext, Expression.Call(methodCallExpression.Object, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>)), manyQuery.Expression));
            }, ref queryTransform);
        }
            
        private static object IncludeManyOneToOneMany<ManyT, OneT>(object oneValues, object[] manyValues, Func<OneT, ManyT, bool> fkTest, Func<OneT, TrackableCollection<ManyT>> getTrackableCollection)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return ((IEnumerable<object>)manyValues).Cast<ManyT>();
        }
            
        public static IWAQSQuery<ManyT> IncludeManyToOne<ManyT, OneT>(IWAQSQuery<ManyT> source, IWAQSQuery<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeManyToOne<ManyT, ManyT, OneT>(source, onesEntitySet, exp, anyExp, queryTransform, fkTest, setOne);
        }
            
        public static IWAQSQuery<ManyBaseT> IncludeManyToOne<ManyBaseT, ManyT, OneT>(IWAQSQuery<ManyBaseT> source, IWAQSQuery<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where ManyT : ManyBaseT
            where ManyBaseT : IEntity
            where OneT : IEntity
        {
            return Include<ManyBaseT, OneT>(source, manyQuery =>
            {
                var include = new QueryableInclude();
                var manyQueryAsAsyncQueryable = manyQuery as IWAQSQuery<ManyBaseT>;
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                if (manyQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<ManyBaseT>)manyQuery, exp, q => q), queryTransform);
                    load = (manyValues, oneValues) => IncludeOneManyToOne(manyValues, oneValues, setOne);
                }
                else
                {
                    subQuery = CreateManyToOneQuery(manyQueryAsAsyncQueryable.OfType<ManyT>(), onesEntitySet, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (manyValues, oneValues) => IncludeManyToOne(manyValues, oneValues, fkTest, setOne);
                }
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static IWAQSQuery<OneT> CreateManyToOneQuery<ManyT, OneT>(IWAQSQuery<ManyT> source, IWAQSQuery<OneT> onesEntitySet, Expression<Func<ManyT, OneT, bool>> exp, ref Expression<Func<OneT, OneT>> queryTransform)
        {
            var oParameter = Expression.Parameter(typeof(OneT), "o" + Guid.NewGuid().ToString("N"));
            var mParameter = Expression.Parameter(typeof(ManyT), "m" + Guid.NewGuid().ToString("N"));
            var query = Where(onesEntitySet, Expression.Lambda<Func<OneT, bool>>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(ManyT)), source.Expression, Expression.Lambda(exp.Body.ReplaceParameter(spe =>
            {
                switch (exp.Parameters.IndexOf(spe))
                {
                    case 0:
                        return mParameter;
                    case 1:
                        return oParameter;
                    default:
                        throw new InvalidOperationException();
                }
            }), mParameter)), oParameter));
            return CreateQuery(_ => query, ref queryTransform);
        }
                                                
        private static object IncludeManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return ((IEnumerable<object>)oneValues[0]).Cast<OneT>();
        }
                                                
        private static object IncludeOneManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return (OneT)oneValues[0];
        }
            
        public static IWAQSQueryValue<ManyT> IncludeOneManyToOne<ManyT, OneT>(IWAQSQueryValue<ManyT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
            where OneT : IEntity
            where ManyT : IEntity
        {
            return IncludeOneManyToOne<ManyT, ManyT, OneT>(source, exp, queryTransform, setOne);
        }
            
        public static IWAQSQueryValue<ManyBaseT> IncludeOneManyToOne<ManyBaseT, ManyT, OneT>(IWAQSQueryValue<ManyBaseT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
            where ManyT : ManyBaseT
            where ManyBaseT : IEntity
            where OneT : IEntity
        {
            return Include<ManyBaseT, OneT>(source, manyQuery =>
            {
                var include = new QueryableInclude();
                IWAQSQueryBase subQuery;
                Func<object, object[], object> load;
                subQuery = CreateQuery(qt => CreateOneToOne((IWAQSQueryValue<ManyBaseT>)manyQuery, exp, q => q), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (manyValues, oneValues) => IncludeOneManyToOne(manyValues, oneValues, setOne);
                include.Queries = new IWAQSQueryBase[] { subQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        public static IWAQSQuery<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IWAQSQuery<FromT> source, IWAQSQuery<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollection<ToT>>> getCollectionExp, Expression<Func<TrackableCollection<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IWAQSQuery<FromT>, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toEntitySet, exp, getCollectionExp, anyExp, queryTransform, getKeysQuery, fromFkTest, toFkTest, getTrackableCollection);
        }
                                                
            public static IWAQSQuery<BaseFromT> IncludeManyToMany<BaseFromT, FromT, ToT, KeysT>(IWAQSQuery<BaseFromT> source, IWAQSQuery<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollection<ToT>>> getCollectionExp, Expression<Func<TrackableCollection<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IWAQSQuery<FromT>, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
                where FromT : class, BaseFromT
                where BaseFromT : class, IEntity
                where ToT : class, IEntity
            {
                return Include<BaseFromT, ToT>(source, fromQuery =>
                {
                    var include = new QueryableInclude();
                    var fromBaseQueryAsAsyncQueryable = fromQuery as IWAQSQuery<BaseFromT>;
                    IWAQSQueryBase toQuery;
                    Func<object, object[], object> load;
                    if (fromBaseQueryAsAsyncQueryable == null)
                    {
                        toQuery = CreateQuery(qt => CreateOneToOne(((IWAQSQueryValue<BaseFromT>)fromQuery), exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                        load = (fromValues, toValues) => IncludeOneOneToMany(fromQuery.DataContext, fromValues, toValues, getTrackableCollection, true);
                        return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery }, Load = load };
                    }
                    var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.OfType<FromT>();
                    toQuery = CreateManyToManyQuery(fromQueryAsAsyncQueryable, toEntitySet, exp, getCollectionExp, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable);
                    if (queryTransform != null)
                    {
                        var selectManyCollectionSelectorExpression = (LambdaExpression)((MethodCallExpression)keysQuery.Expression).Arguments[1];
                        selectManyCollectionSelectorExpression = Expression.Lambda(queryTransform.Body.ReplaceParameter(queryTransform.Parameters[0], selectManyCollectionSelectorExpression.Body), selectManyCollectionSelectorExpression.Parameters);
                    }
                    load = (fromValues, toValues) => IncludeManyToMany(fromQuery.DataContext, fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                    include.Queries = new IWAQSQueryBase[] { toQuery, keysQuery };
                    include.Load = load;
                    return include;
                });
            }
                                                
        private static IWAQSQuery<ToT> CreateManyToManyQuery<FromT, ToT>(IWAQSQuery<FromT> source, IWAQSQuery<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollection<ToT>>> getCollectionExp, Expression<Func<TrackableCollection<ToT>, ToT, bool>> anyExp, ref Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform)
            where FromT : IEntity
            where ToT : IEntity
        {
            return CreateQuery(qt =>
            {
                var toParameter = Expression.Parameter(typeof(ToT), "t" + Guid.NewGuid().ToString("N"));
                IWAQSQuery<ToT> toQuery;
                if (qt == null)
                {
                    var fromParameter = Expression.Parameter(typeof(FromT), "f" + Guid.NewGuid().ToString("N"));
                    toQuery = Where(toEntitySet, Expression.Lambda<Func<ToT, bool>>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(FromT)), source.Expression, Expression.Lambda(anyExp.Body.ReplaceParameter(spe =>
                    {
                        switch (anyExp.Parameters.IndexOf(spe))
                        {
                            case 0:
                                return getCollectionExp.Body.ReplaceParameter(getCollectionExp.Parameters[0], fromParameter);
                            case 1:
                                return toParameter;
                            default:
                                throw new InvalidOperationException();
                        }
                    }), fromParameter)), toParameter));
                }
                else
                    toQuery = Where(toEntitySet, Expression.Lambda<Func<ToT, bool>>(Expression.Call(typeof(Queryable).GetMethod("Contains"), source.Select(exp).Select(qt).SelectMany(e => e).Expression, toParameter), toParameter)); 
                return CreateWAQSQuery<ToT>(source.DataContext, toQuery, source.AsyncQueryProviderFactory, source.ExpressionTransformation);
            }, ref queryTransform);
        }
            
        public static IWAQSQuery<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IWAQSQuery<FromT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            return IncludeManyToOneMany<FromT, FromT, ToT, KeysT>(source, exp, queryTransform, getKeysQuery, getTo, getFromKey, getTrackableCollection);
        }
            
        public static IWAQSQuery<FromBaseT> IncludeManyToOneMany<FromBaseT, FromT, ToT, KeysT>(IWAQSQuery<FromBaseT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, FromBaseT
            where FromBaseT : class, IEntity
            where ToT : class, IEntity
        {
            return Include<FromBaseT, ToT>(source, fromQuery =>
            {
                var include = new QueryableInclude();
                var fromBaseQueryAsAsyncQueryable = fromQuery as IWAQSQuery<FromBaseT>;
                IWAQSQueryBase toQuery;
                Func<object, object[], object> load;
                if (fromBaseQueryAsAsyncQueryable == null)
                {
                    toQuery = CreateQuery(qt => CreateOneToOne(((IWAQSQueryValue<FromBaseT>)fromQuery), exp, q => q.Select(qt)), queryTransform);
                    load = (fromValues, toValues) => IncludeOneOneToMany(fromQuery.DataContext, fromValues, toValues, getTrackableCollection, true);
                    return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery }, Load = load };
                }
                var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.OfType<FromT>();
                toQuery = CreateQuery(qt => CreateWAQSQuery(source.DataContext, fromQueryAsAsyncQueryable.Select(exp).Select(qt), source.AsyncQueryProviderFactory, source.ExpressionTransformation), ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                ToT toT = null;
                var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable, toT);
                var select = (MethodCallExpression)keysQuery.Expression;
                var selectLambda = (LambdaExpression)select.Arguments[1];
                var keysCtor = (NewExpression)((LambdaExpression)select.Arguments[1]).Body;
                var keysCtorToArg = keysCtor.Arguments.Last();
                keysCtorToArg = queryTransform.Body.ReplaceParameter(queryTransform.Parameters[0], exp.Body.ReplaceParameter(exp.Parameters[0], selectLambda.Parameters[0]));
                var keysCtorArguments = keysCtor.Arguments.ToList();
                keysCtorArguments[keysCtor.Arguments.Count - 1] = keysCtorToArg;
                keysCtor = Expression.New(keysCtor.Constructor, keysCtorArguments);
                                    
                keysQuery = CreateWAQSQuery<KeysT>(keysQuery.DataContext, keysQuery, keysQuery.AsyncQueryProviderFactory, keysQuery.ExpressionTransformation, toQuery.QueryableIncludes);
                                                
                load = (fromValues, toValues) => IncludeManyToOneMany<FromT, ToT, KeysT>(fromQuery.DataContext, fromValues, toValues, getTo, getFromKey, getTrackableCollection);
                include.Queries = new IWAQSQueryBase[] { keysQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static object IncludeManyToOneMany<FromT, ToT, KeysT>(IDataContext context, object fromValues, object[] toValues, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where ToT : class, IEntity
        {
            var keys = ((IEnumerable<object>)toValues[0]).Cast<KeysT>().ToList();
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
            var tos = new List<ToT>();
            foreach (var key in keys)
            {
                var to = getTo(key);
                if (to != null)
                {
                    getTrackableCollection(froms.FirstOrDefault(f => getFromKey(key, f))).Attach(getTo(key), context);
                    tos.Add(to);
                }
            }
            return tos;
        }
                                                
            public static IWAQSQuery<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IWAQSQuery<FromT> source, IWAQSQuery<ToT> toQuery, Func<IWAQSQuery<FromT>, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQuery, Func<FromT, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
                where FromT : class, IEntity
                where ToT : class, IEntity
            {
                return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toQuery, getKeysQuery, getKeysQueryForOne, fromFkTest, toFkTest, getTrackableCollection);
            }
            
            public static IWAQSQuery<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IWAQSQuery<FromT> source, IWAQSQuery<ToT> toQuery, Func<IWAQSQuery<FromT>, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQuery, Func<FromT, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
                where FromT : class, FromBaseT
                where FromBaseT : class, IEntity
                where ToT : class, IEntity
            {
                if (source.DataContext != toQuery.DataContext)
                    throw new InvalidOperationException();
                return Include<FromT, ToT>(source, fromQuery =>
                {
                    var fromBaseQueryAsAsyncQueryable = fromQuery as IWAQSQuery<FromBaseT>;
                    Func<object, object[], object> load;
                    IWAQSQuery<KeysT> keysQuery;
                    if (fromBaseQueryAsAsyncQueryable == null)
                    {
                        keysQuery = CreateOneManyToManyKeysQuery(((IWAQSQueryValue<FromT>)fromQuery), toQuery, getKeysQueryForOne);
                        load = (fromValues, toValues) => IncludeOneManyToMany<FromT, ToT, KeysT>(fromQuery.DataContext, fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                        return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery, keysQuery }, Load = load };
                    }
                    keysQuery = getKeysQuery(fromBaseQueryAsAsyncQueryable.OfType<FromT>(), toQuery);
                    load = (fromValues, toValues) => IncludeManyToMany<FromT, ToT, KeysT>(fromQuery.DataContext, fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                    return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery, keysQuery }, Load = load };
                });
            }                                    
        public static IWAQSQuery<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IWAQSQuery<FromT> source, IWAQSQueryValue<ToT> toQuery, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            if (source.DataContext != toQuery.DataContext)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
            {
                Func<object, object[], object> load;
                IWAQSQueryBase keysQuery;
                var fromQueryAsAsyncQueryable = fromQuery as IWAQSQuery<FromT>;
                if (fromQueryAsAsyncQueryable == null)
                {
                    keysQuery = CreateOneManyToOneManyKeysQuery(((IWAQSQueryValue<FromT>)fromQuery), toQuery, getKeysQuery);
                    load = (fromValues, toValues) => IncludeOneManyToOneMany(fromQuery.DataContext, fromValues, toValues, getTrackableCollection);
                    return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery }, Load = load };
                }
                keysQuery = CreateManyToOneManyKeysQuery(fromQueryAsAsyncQueryable, toQuery, getKeysQuery);
                load = (fromValues, toValues) => IncludeOneManyToMany(fromQuery.DataContext, fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery, keysQuery }, Load = load };
            });
        }
                                                
        public static IWAQSQueryValue<FromT> IncludeOneManyToMany<FromT, ToT, KeysT>(IWAQSQueryValue<FromT> source, IWAQSQuery<ToT> toQuery, Func<FromT, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            if (source.DataContext != toQuery.DataContext)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToManyKeysQuery(source, toQuery, getKeysQuery);
                Func<object, object[], object> load = (fromValues, toValues) => IncludeOneManyToMany(fromQuery.DataContext, fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery, keysQuery }, Load = load };
            });
        }
                                                
        public static IWAQSQueryValue<FromT> IncludeOneManyToOneMany<FromT, ToT, KeysT>(IWAQSQueryValue<FromT> source, IWAQSQueryValue<ToT> toQuery, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            if (source.DataContext != toQuery.DataContext)
                throw new InvalidOperationException();
            return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToOneManyKeysQuery(source, toQuery, getKeysQuery);
                Func<object, object[], object> load = (fromValues, toValues) => IncludeOneManyToOneMany(fromQuery.DataContext, fromValues, toValues, getTrackableCollection);
                return new QueryableInclude { Queries = new IWAQSQueryBase[] { toQuery, keysQuery }, Load = load };
            });
        }
                                                
        private static IWAQSQuery<KeysT> CreateOneManyToManyKeysQuery<FromT, ToT, KeysT>(IWAQSQueryValue<FromT> fromQuery, IWAQSQuery<ToT> toQuery, Func<FromT, IWAQSQuery<ToT>, IWAQSQuery<KeysT>> getKeysQuery)
            where FromT : class, IEntity
            where ToT : IEntity
        {
            FromT fromT = null;
            var keysQuery = getKeysQuery(fromT, toQuery);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
                {
                    if (constant.Value == fromT)
                        return fromQuery.Expression;
                    return constant;
                });
            return CreateWAQSQuery<KeysT>(keysQuery.DataContext, keysQuery.Provider.CreateQuery<KeysT>(keysQueryExpression), keysQuery.AsyncQueryProviderFactory, keysQuery.ExpressionTransformation);
        }
                                                
        private static IWAQSQuery<KeysT> CreateManyToOneManyKeysQuery<FromT, ToT, KeysT>(IWAQSQuery<FromT> fromQuery, IWAQSQueryValue<ToT> toQuery, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery)
            where FromT : IEntity
            where ToT : class, IEntity
        {
            ToT toT = null;
            var keysQuery = getKeysQuery(fromQuery, toT);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
            {
                if (constant.Value == toT)
                    return toQuery.Expression;
                return constant;
            });
            keysQuery = CreateWAQSQuery<KeysT>(keysQuery.DataContext, keysQuery.Provider.CreateQuery<KeysT>(keysQueryExpression), keysQuery.AsyncQueryProviderFactory, keysQuery.ExpressionTransformation);
            return keysQuery;
        }
                                                
        private static IWAQSQueryValue<KeysT> CreateOneManyToOneManyKeysQuery<FromT, ToT, KeysT>(IWAQSQueryValue<FromT> fromQuery, IWAQSQueryValue<ToT> toQuery, Func<IWAQSQuery<FromT>, ToT, IWAQSQuery<KeysT>> getKeysQuery)
            where FromT : class, IEntity
            where ToT : class, IEntity
        {
            MethodInfo method;
            var fromQueryAsAsyncQueryable = CreateToOne<FromT>(fromQuery, (MethodCallExpression)fromQuery.Expression, out method);
            ToT toT = null;
            var keysQuery = getKeysQuery(CreateWAQSQuery<FromT>(fromQuery.DataContext, fromQueryAsAsyncQueryable, fromQueryAsAsyncQueryable.AsyncQueryProviderFactory, fromQueryAsAsyncQueryable.ExpressionTransformation), toT);
            var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
            {
                if (constant.Value == toT)
                    return toQuery.Expression;
                return constant;
            });
            return CreateWAQSQueryValue<KeysT>(fromQuery.WAQSQueryProvider, fromQuery.DataContext, Expression.Call(method.MakeGenericMethod(typeof(KeysT)), keysQueryExpression));
        }
                                                
        private static object IncludeManyToMany<FromT, ToT, KeysT>(IDataContext context, object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where ToT : class, IEntity
        {
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
            var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                FromT fromValue = froms.FirstOrDefault(f => fromFkTest(key, f));
                ToT toValue;
                if (fromValue != null && (toValue = tos.FirstOrDefault(t => toFkTest(key, t))) != null)
                    getTrackableCollection(fromValue).Attach(toValue, context);
            }
            return tos;
        }
                                                
        private static object IncludeManyToOneManyTask<FromT, ToT, KeysT>(IDataContext context, object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where ToT : class, IEntity
        {
            var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
            var to = (ToT)toValues[0];
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                var @from = froms.FirstOrDefault(f => fromFkTest(key, f));
                if (@from != null && toFkTest(key, to))
                    getTrackableCollection(@from).Attach(to, context);
            }
            return to;
        }
                                                
        private static object IncludeOneManyToMany<FromT, ToT, KeysT>(IDataContext context, object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where ToT : class, IEntity
        {
            var @from = (FromT)fromValues;
            var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
            var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
            foreach (var key in keys)
            {
                var toValue = tos.FirstOrDefault(t => toFkTest(key, t));
                if (toValue != null && fromFkTest(key, @from))
                    getTrackableCollection(@from).Attach(toValue, context);
            }
            return tos;
        }
                                                
        private static object IncludeOneManyToOneMany<FromT, ToT>(IDataContext context, object fromValues, object[] toValues, Func<FromT, TrackableCollection<ToT>> getTrackableCollection)
            where ToT : class, IEntity
        {
            var fromValue = (FromT)fromValues;
            var toValue = (ToT)toValues[0];
            getTrackableCollection(fromValue).Attach(toValue, context);
            return toValue;
        }
            
        public static IWAQSQueryValue<IEnumerable<FromT>> IncludeManyOneToOne<FromT, ToT>(IWAQSQueryValue<IEnumerable<FromT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : IEntity
            where ToT : IEntity
        {
            return IncludeManyOneToOne<FromT, FromT, ToT>(source, exp, queryTransform, fkTest, setTo);
        }
            
        public static IWAQSQueryValue<IEnumerable<FromBaseT>> IncludeManyOneToOne<FromBaseT, FromT, ToT>(IWAQSQueryValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : FromBaseT
            where FromBaseT : IEntity
            where ToT : IEntity
        {
            return Include<IEnumerable<FromBaseT>, ToT>(source, fromQuery =>
            {
                var include = new QueryableInclude();
                var toQuery = CreateManyOneToOne(((IWAQSQueryValue<IEnumerable<FromBaseT>>)source), exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                Func<object, object[], object> load = (fromValues, toValues) => IncludeManyOneToOne(fromValues, toValues, fkTest, setTo);
                include.Queries = new IWAQSQueryBase[] { toQuery };
                include.Load = load;
                return include;
            });
        }
                                                
        private static IWAQSQueryValue<IEnumerable<ToT>> CreateManyOneToOne<FromBaseT, FromT, ToT>(IWAQSQueryValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, ref Expression<Func<ToT, ToT>> queryTransform)
            where FromT : FromBaseT
        {
            return CreateQuery(qt =>
            {
                if (qt == null)
                    qt = e => e;
                var serializableMethodCallExpression = (MethodCallExpression)source.Expression;
                MethodInfo method;
                var baseQuery = CreateToOne<IEnumerable<FromT>>(source, serializableMethodCallExpression, out method).Select(fs => fs.OfType<FromT>());
                var selectParameter = Expression.Parameter(typeof(IEnumerable<FromT>), "e" + Guid.NewGuid().ToString("N"));
                var expTo = Expression.Lambda<Func<FromT, ToT>>(qt.Body.ReplaceParameter(qt.Parameters[0], exp.Body), exp.Parameters[0]);
                var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<FromT>, IEnumerable<ToT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(ToT)), Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(FromT), typeof(ToT)), selectParameter, expTo)), selectParameter));
                return CreateWAQSQueryValue<IEnumerable<ToT>>(source.WAQSQueryProvider, source.DataContext, Expression.Call(serializableMethodCallExpression.Object, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ToT>)), manyQuery.Expression));
            }, ref queryTransform);
        }
                                                
        private static object IncludeManyOneToOne<FromT, ToT>(object fromValues, object[] toValues, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
            where FromT : IEntity
            where ToT : IEntity
        {
            return ((IEnumerable<object>)toValues).Cast<ToT>();
        }
                                                
        public static IWAQSQuery<QueryT> ReplaceType<QueryT, OldT, NewT>(this IWAQSQuery<QueryT> query)
        {
            return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
        }
                                                
        public static IWAQSQuery<NewT> ReplaceType<OldT, NewT>(this IWAQSQuery<OldT> query)
        {
            return ReplaceType<OldT, NewT, OldT, NewT>(query);
        }
                                                
        public static IWAQSQuery<NewT> ReplaceType<OldT, NewT>(this IWAQSQuery<NewT> query)
        {
            return ReplaceType<NewT, NewT, OldT, NewT>(query);
        }
                                                
        private static IWAQSQuery<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IWAQSQuery<OldQueryT> query)
        {
            return CreateWAQSQuery<NewQueryT>(query.DataContext, query.Provider.CreateQuery<NewQueryT>(new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression)), query.AsyncQueryProviderFactory, query.ExpressionTransformation, query.QueryableIncludes, query.WithSpecifications);
        }
                                                
        private static IWAQSQuery<T> ApplyIncludesAndWiths<T>(IWAQSQuery originalQuery, IQueryable<T> query)
        {
            var value = (IWAQSQuery<T>)query;
            value.QueryableIncludes = originalQuery.QueryableIncludes;
            value.WithSpecifications = originalQuery.WithSpecifications;
            return value;
        }
                            
        public static IWAQSQuery<T> CreateWAQSQuery<T>(IDataContext dataContext, IQueryable<T> queryable, IAsyncQueryProviderFactory asyncQueryProviderFactory, Func<Expression, Expression> expressionTransformation, IEnumerable<Func<IWAQSQueryBase, QueryableInclude>> queryableIncludes = null, IEnumerable<string> withSpecifications = null)
        {
            var value = new WAQSQuery<T>(dataContext, queryable, asyncQueryProviderFactory, expressionTransformation);
            if (queryableIncludes != null)
                value.QueryableIncludes = queryableIncludes;
            if (withSpecifications != null)
                value.WithSpecifications = withSpecifications;
            return value;
        }
                                    
        public static IWAQSQuery<T> CreateWAQSQuery<T>(IWAQSQuery<T> originalQuery, IEnumerable<Func<IWAQSQueryBase, QueryableInclude>> queryableIncludes = null, IEnumerable<string> withSpecifications = null)
        {
            var value = new WAQSQuery<T>(originalQuery);
            if (queryableIncludes != null)
                value.QueryableIncludes = queryableIncludes;
            if (withSpecifications != null)
                value.WithSpecifications = withSpecifications;
            return value;
        }
                            
        public static IWAQSQueryValue<T> CreateWAQSQueryValue<T>(IWAQSQueryValue<T> originalQueryValue, IEnumerable<Func<IWAQSQueryBase, QueryableInclude>> queryableIncludes = null, IEnumerable<string> withSpecifications = null)
        {
            var value = new WAQSQueryValue<T>(originalQueryValue) { QueryableIncludes = queryableIncludes, WithSpecifications = withSpecifications };
            if (queryableIncludes != null)
                value.QueryableIncludes = queryableIncludes;
            if (withSpecifications != null)
                value.WithSpecifications = withSpecifications;
            return value;
        }
                            
        public static IWAQSQueryValue<T> CreateWAQSQueryValue<T>(WAQSQueryProvider waqsQueryProvider, IDataContext dataContext, Expression expression, IEnumerable<Func<IWAQSQueryBase, QueryableInclude>> queryableIncludes = null, IEnumerable<string> withSpecifications = null)
        {
            var value = new WAQSQueryValue<T>(waqsQueryProvider, dataContext, expression);
            if (queryableIncludes != null)
                value.QueryableIncludes = queryableIncludes;
            if (withSpecifications != null)
                value.WithSpecifications = withSpecifications;
            return value;
        }
        
        public static void Load<T>(IWAQSQuery<T> source)
        {
            using (var enumerator = source.GetEnumerator())
            {
                while (enumerator.MoveNext()) ;
            }
        }
        
        public static Task<bool> AllAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<bool>(Expression.Call(typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<bool> AnyAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<bool>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<bool> AnyAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<bool>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(new Type[] { typeof(T) }), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<decimal> AverageAsync(this IWAQSQuery<decimal> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<decimal>(source, cancellationToken);
        }
            
        public static Task<decimal> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, decimal>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, decimal>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<decimal?> AverageAsync(this IWAQSQuery<decimal?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<decimal?>(source, cancellationToken);
        }
            
        public static Task<decimal?> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, decimal?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, decimal?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<double> AverageAsync(this IWAQSQuery<double> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<double>(source, cancellationToken);
        }
            
        public static Task<double> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, double>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, double>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<double?> AverageAsync(this IWAQSQuery<double?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<double?>(source, cancellationToken);
        }
            
        public static Task<double?> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, double?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, double?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<int> AverageAsync(this IWAQSQuery<int> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<int>(source, cancellationToken);
        }
            
        public static Task<int> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, int>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, int>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<int?> AverageAsync(this IWAQSQuery<int?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<int?>(source, cancellationToken);
        }
            
        public static Task<int?> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, int?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, int?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<long> AverageAsync(this IWAQSQuery<long> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<long>(source, cancellationToken);
        }
            
        public static Task<long> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, long>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, long>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<long?> AverageAsync(this IWAQSQuery<long?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<long?>(source, cancellationToken);
        }
            
        public static Task<long?> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, long?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, long?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<float> AverageAsync(this IWAQSQuery<float> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<float>(source, cancellationToken);
        }
            
        public static Task<float> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, float>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, float>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<float?> AverageAsync(this IWAQSQuery<float?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<float?>(source, cancellationToken);
        }
            
        public static Task<float?> AverageAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, float?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return AverageAsync<T, float?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        private static Task<T> AverageAsync<T>(IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            ParameterInfo[] parameters;
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Average" && (parameters = m.GetParameters()).Length == 1 && parameters[0].ParameterType == typeof(IQueryable<T>)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        private static Task<T2> AverageAsync<T, T2>(IWAQSQuery<T> source, Expression<Func<T, T2>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            ParameterInfo[] parameters;
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T2>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Average" && (parameters = m.GetParameters()).Length == 2 && parameters[1].ParameterType.GetGenericArguments()[0].GetGenericArguments()[1] == typeof(T2)).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, selector)) }), cancellationToken);
        }
            
        public static Task<bool> ContainsAsync<T>(this IWAQSQuery<T> source, T item, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<bool>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Constant(item, typeof(T)) }), cancellationToken);
        }
            
        public static Task<int> CountAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<int>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<int> CountAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<int>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<T> FirstAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T> FirstAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<T> FirstOrDefaultAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T> FirstOrDefaultAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task LoadAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return source.ForeachAsync(_ => { }, cancellationToken);
        }
            
        public static Task<long> LongCountAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<long>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<long> LongCountAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<long>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<T> MaxAsync<T>(IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T2> MaxAsync<T, T2>(this IWAQSQuery<T> source, Expression<Func<T, T2>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T2>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T), typeof(T2)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, selector)) }), cancellationToken);
        }
            
        public static Task<T> MinAsync<T>(IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T2> MinAsync<T, T2>(this IWAQSQuery<T> source, Expression<Func<T, T2>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T2>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T), typeof(T2)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, selector)) }), cancellationToken);
        }
            
        public static Task<T> SingleAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().Single(m => m.Name == "Single" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T> SingleAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().Single(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<T> SingleOrDefaultAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().Single(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        public static Task<T> SingleOrDefaultAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default(CancellationToken))
        {
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().Single(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, predicate)) }), cancellationToken);
        }
            
        public static Task<decimal> SumAsync(this IWAQSQuery<decimal> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<decimal>(source, cancellationToken);
        }
            
        public static Task<decimal> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, decimal>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, decimal>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<decimal?> SumAsync(this IWAQSQuery<decimal?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<decimal?>(source, cancellationToken);
        }
            
        public static Task<decimal?> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, decimal?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, decimal?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<double> SumAsync(this IWAQSQuery<double> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<double>(source, cancellationToken);
        }
            
        public static Task<double> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, double>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, double>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<double?> SumAsync(this IWAQSQuery<double?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<double?>(source, cancellationToken);
        }
            
        public static Task<double?> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, double?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, double?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<int> SumAsync(this IWAQSQuery<int> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<int>(source, cancellationToken);
        }
            
        public static Task<int> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, int>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, int>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<int?> SumAsync(this IWAQSQuery<int?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<int?>(source, cancellationToken);
        }
            
        public static Task<int?> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, int?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, int?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<long> SumAsync(this IWAQSQuery<long> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<long>(source, cancellationToken);
        }
            
        public static Task<long> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, long>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, long>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<long?> SumAsync(this IWAQSQuery<long?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<long?>(source, cancellationToken);
        }
            
        public static Task<long?> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, long?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, long?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<float> SumAsync(this IWAQSQuery<float> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<float>(source, cancellationToken);
        }
            
        public static Task<float> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, float>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, float>(source, GetExpression(source, selector), cancellationToken);
        }
            
        public static Task<float?> SumAsync(this IWAQSQuery<float?> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<float?>(source, cancellationToken);
        }
            
        public static Task<float?> SumAsync<T>(this IWAQSQuery<T> source, Expression<Func<T, float?>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            return SumAsync<T, float?>(source, GetExpression(source, selector), cancellationToken);
        }
            
        private static Task<T> SumAsync<T>(IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            ParameterInfo[] parameters;
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && (parameters = m.GetParameters()).Length == 1 && parameters[0].ParameterType == typeof(IQueryable<T>)), new Expression[] { source.Expression }), cancellationToken);
        }
            
        private static Task<T2> SumAsync<T, T2>(IWAQSQuery<T> source, Expression<Func<T, T2>> selector, CancellationToken cancellationToken = default(CancellationToken))
        {
            ParameterInfo[] parameters;
            return ((WAQSQueryProvider)source.Provider).ExecuteAsync<T2>(Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && (parameters = m.GetParameters()).Length == 2 && parameters[1].ParameterType.GetGenericArguments()[0].GetGenericArguments()[1] == typeof(T2)).MakeGenericMethod(typeof(T)), new Expression[] { source.Expression, Expression.Quote(GetExpression(source, selector)) }), cancellationToken);
        }
            
        public async static Task<T[]> ToArrayAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            return (await source.ToListAsync(cancellationToken)).ToArray();
        }
            
        public async static Task<List<T>> ToListAsync<T>(this IWAQSQuery<T> source, CancellationToken cancellationToken = default(CancellationToken))
        {
            var result = new List<T>();
            await source.ForeachAsync(item => result.Add(item), cancellationToken);
            return result;
        }
    }
}
